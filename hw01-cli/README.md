# CLI

## Инструкция по сборке

Проект собирается с помощью `cmake` и `make`

Будем собирать программу в папке `build`, предполагая, что находимся
в корневой папке проекта.

Нужно:

1. Создать папку `build`

`mkdir build`

2. Перейти в папку `build`

`cd build`

3. Сгенерировать `Makefile`

`cmake ..`

4. Собрать проект

`make`

5. Запуск

* CLI: `./hw01_cli`

* tests: `./test/hw01_cli_tests`

## Описание сущностей

### Каналы

Абстракция для передачи данных между процессами, которые выполняются
последовательно (разделяются с помощью `PIPE` (`|`)). 
При этом выходной (`IOutputChannel`) канал передается в качестве 
входного (`IInputChannel`) канала следующему потоку.

В первоначальной реализации везде используется `StringChannel`,
который реализует оба интерфейса (как для чтения, так и для записи).

`StringChannel` хранит в себе строку из символов.
При записи в канал выполняется конкатенация текущего буффера
с аргументом, а при чтении выдается весь буффер наружу, при этом
буффер очищается.

### Токенизация

Есть интерфейс `ITokenizer`. Реализаующие его тоекнизаторы
должны уметь добавлять в себя строку (дописывание строки)
и возвращать следующий токен.

Класс `Token` является единицой для токенизаторов, одной нерушимой частью,
из которых состоит строка. Таким образом основная задача классов, реализующих
интерфейс `ITokenizer` разбивать строку на токены (`Token`).

Класс `LinearTokenzer` реализует интерфейс `ITokenizer` следующим образом:

* Подстроки между двумя кавычками одинаково типа являются одним токеном,
причем если тоен начинается с кавычки, то он закончится **с первой** кавычки того же типа
в строке. Все, что осталось между этими кавычками является одним токеном типа
`LITERAL`. 

* Считает символы `{|(PIPE),=(ASSIGN),$(DOLLAR), (SPACE)}` специальными, для них есть токены специального типа.
Если символ встретился в токене типа `LITERAL` (т.е. оказался между двумя одинаковыми кавычками),
то он **не считается специальным**. Последний символ в множестве - это пробел 
(любой пробельный символ) 

* В качестве самого последнего токена вернет токен типа `END`, после того,
как был вернут `END` дальнейшее использование `LinearTokenizer` может привести
к неопределенному поведению.

### Окружение

* Класс `Environment` представляет из себя оболочку, в которой обарбатывается
хранение переменных, а также работа с утилитами, которые прописаны в `shell`'е
(`cat`, `pwd`, ...)

* Есть поддержка переменной `$?`, в которой хранится код возврата последней операции

### Команды

Для команды есть обертка в виде класса `Command`, которая внутри себя хранит
имя (`CommandName`) и аргументы (`CommandArguments`).

`CommandArguments` представляет из себя массив токенов (`Token`).

`CommandName` - обертка на строкой, которая хранит в себе имя команды.

Команды можно строить посредством строителя `CommandBuilder`, который умеет дописывать
в себе новые токены. Причем, если в нем не было токенов, то первый токен он добавит
только в том случае, если этот токен не пуст (соответствует непустой строке) и
является `LITERA`'ом.

Команды будут вызываться по имени с помощью фабрики `CommadnExecutorFactory`, который
умеет по имени выдавать соответствующий `ICommandExecutor`.

### Подстановка

Для реализации оператора присваивания и подстановки в переменные окружения
был введен класс `Substitutor`. Он не имеет состояния, поэтому все его
методы статические. Этот класс умеет подставлять (конструкция вида `name=value`) значение переменно
вместо конструкции `$name`, если `name` удовлетворяет ограничениями на имя
переменной. Причем подстановка может быть произведена только внутри токенов,
которые ограничены с обоих сторон двойными кавычками. По-умолчанию
переменная имеет значение `""` - пустая строка.
